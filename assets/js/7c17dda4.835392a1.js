"use strict";(self.webpackChunkcommunity_flake_parts=self.webpackChunkcommunity_flake_parts||[]).push([[83],{7433:(e,l,n)=>{n.r(l),n.d(l,{assets:()=>r,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>t,toc:()=>c});var s=n(5893),a=n(1151);const i={slug:"/haskell-flake/nixpkgs-haskell"},o="Nixifying a Haskell project using nixpkgs",t={id:"modules/haskell-flake/ref/nixpkgs-haskell",title:"Nixifying a Haskell project using nixpkgs",description:"This tutorial enables you to write a flake using nothing but nixpkgs] to nixify an existing Haskell project. The tutorial serves a pedagogic purpose; in the real-world scenario, we recommend that you use [haskell-flake.",source:"@site/docs/modules/haskell-flake/ref/nixpkgs-haskell.md",sourceDirName:"modules/haskell-flake/ref",slug:"/haskell-flake/nixpkgs-haskell",permalink:"/haskell-flake/nixpkgs-haskell",draft:!1,unlisted:!1,editUrl:"https://github.com/srid/haskell-flake/blob/master/doc/ref/nixpkgs-haskell.md",tags:[],version:"current",frontMatter:{slug:"/haskell-flake/nixpkgs-haskell"},sidebar:"tutorialSidebar",previous:{title:"Building a docker image",permalink:"/haskell-flake/docker"},next:{title:"Examples",permalink:"/haskell-flake/examples"}},r={},c=[{value:"callCabal2nix",id:"callcabal2nix",level:2},{value:"Package sets",id:"package-sets",level:2},{value:"Overlays",id:"overlays",level:3},{value:"Development shell",id:"development-shell",level:2},{value:"Haskell shell",id:"haskell-shell",level:3},{value:"Example",id:"example",level:2}];function h(e){const l={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(l.h1,{id:"nixifying-a-haskell-project-using-nixpkgs",children:"Nixifying a Haskell project using nixpkgs"}),"\n",(0,s.jsxs)(l.p,{children:["This tutorial enables you to write a flake using nothing but ",(0,s.jsx)(l.a,{href:"https://zero-to-nix.com/concepts/nixpkgs",children:"nixpkgs"})," to nixify an existing Haskell project. The tutorial serves a pedagogic purpose; in the real-world scenario, we recommend that you use ",(0,s.jsx)(l.a,{href:"/haskell-flake/start",children:"haskell-flake"}),"."]}),"\n",(0,s.jsxs)(l.p,{children:[(0,s.jsx)(l.a,{href:"https://zero-to-nix.com/concepts/nixpkgs",children:"nixpkgs"})," provides two important functions for developing Haskell projects that we'll extensively use here. They are ",(0,s.jsx)(l.code,{children:"callCabal2nix"})," and ",(0,s.jsx)(l.code,{children:"shellFor"}),", and are described below."]}),"\n",(0,s.jsx)(l.admonition,{title:"To learn more",type:"info",children:(0,s.jsxs)(l.ul,{children:["\n",(0,s.jsx)(l.li,{children:(0,s.jsx)(l.a,{href:"https://nixos.org/manual/nixpkgs/unstable/#haskell",children:"Official manual"})}),"\n"]})}),"\n",(0,s.jsx)(l.h2,{id:"callcabal2nix",children:"callCabal2nix"}),"\n",(0,s.jsxs)(l.p,{children:[(0,s.jsx)(l.a,{href:"https://github.com/NixOS/nixpkgs/blob/master/pkgs/development/haskell-modules/make-package-set.nix",children:(0,s.jsx)(l.code,{children:"callCabal2nix"})})," produces a derivation for building a Haskell package from source. This source can be any path, including a local directory (eg.: ",(0,s.jsx)(l.code,{children:"./."}),") or a flake input. We'll use ",(0,s.jsx)(l.code,{children:"callCabal2nix"})," to build a package from source during overriding the Haskell package set using overlays (see below)."]}),"\n",(0,s.jsx)(l.h2,{id:"package-sets",children:"Package sets"}),"\n",(0,s.jsxs)(l.p,{children:[(0,s.jsx)(l.a,{href:"https://zero-to-nix.com/concepts/nixpkgs",children:"nixpkgs"})," also provides a Haskell package set (built, in part, from Stackage but also Hackage) for each GHC compiler version. The default compiler's package set is provided in ",(0,s.jsx)(l.code,{children:"pkgs.haskellPackages"}),". In the repl session below, we locate and build the ",(0,s.jsx)(l.code,{children:"aeson"})," package:"]}),"\n",(0,s.jsx)(l.pre,{children:(0,s.jsx)(l.code,{className:"language-nix",children:"\u276f nix repl github:nixos/nixpkgs/nixpkgs-unstable\nnix-repl> pkgs = legacyPackages.${builtins.currentSystem}\n\nnix-repl> pkgs.haskellPackages.aeson\n\xabderivation /nix/store/sjaqjjnizd7ybirh94ixs51x4n17m97h-aeson-2.0.3.0.drv\xbb\n\nnix-repl> :b pkgs.haskellPackages.aeson\n\nThis derivation produced the following outputs:\n  doc -> /nix/store/xjvm45wxqasnd5p2kk9ngcc0jbjhx1pf-aeson-2.0.3.0-doc\n  out -> /nix/store/1dc6b11k93a6j9im50m7qj5aaa5p01wh-aeson-2.0.3.0\n"})}),"\n",(0,s.jsx)(l.h3,{id:"overlays",children:"Overlays"}),"\n",(0,s.jsx)(l.admonition,{title:"To learn more",type:"info",children:(0,s.jsxs)(l.ul,{children:["\n",(0,s.jsx)(l.li,{children:(0,s.jsx)(l.a,{href:"https://nixos.wiki/wiki/Overlays",children:"NixOS Wiki on Overlays"})}),"\n",(0,s.jsx)(l.li,{children:(0,s.jsx)(l.a,{href:"https://github.com/NixOS/nixpkgs/blob/master/lib/fixed-points.nix",children:"Overlay implementation in fixed-points.nix"})}),"\n"]})}),"\n",(0,s.jsxs)(l.p,{children:["Using the overlay system, you can ",(0,s.jsx)(l.em,{children:"extend"})," this package set, to either add new packages or override existing ones. The package set exposes a function called ",(0,s.jsx)(l.code,{children:"extend"})," for this purpose. In the repl session below, we extend the default Haskell package set to override the ",(0,s.jsx)(l.code,{children:"shower"})," package to be built from the Git repo instead:"]}),"\n",(0,s.jsx)(l.pre,{children:(0,s.jsx)(l.code,{className:"language-nix",children:'nix-repl> :b pkgs.haskellPackages.shower\n\nThis derivation produced the following outputs:\n  doc -> /nix/store/crzcx007h9j0p7qj35kym2rarkrjp9j1-shower-0.2.0.3-doc\n  out -> /nix/store/zga3nhqcifrvd58yx1l9aj4raxhcj2mr-shower-0.2.0.3\n\nnix-repl> myHaskellPackages = pkgs.haskellPackages.extend \n    (self: super: {\n       shower = self.callCabal2nix "shower" \n         (pkgs.fetchgit { \n            url = "https://github.com/monadfix/shower.git";\n            rev = "2d71ea1"; \n            sha256 = "sha256-vEck97PptccrMX47uFGjoBVSe4sQqNEsclZOYfEMTns="; \n         }) {}; \n    })\n\nnix-repl> :b myHaskellPackages.shower\n\nThis derivation produced the following outputs:\n  doc -> /nix/store/vkpfbnnzyywcpfj83pxnj3n8dfz4j4iy-shower-0.2.0.3-doc\n  out -> /nix/store/55cgwfmayn84ynknhg74bj424q8fz5rl-shower-0.2.0.3\n'})}),"\n",(0,s.jsxs)(l.p,{children:["Notice how we used ",(0,s.jsx)(l.code,{children:"callCabal2nix"})," to build a new Haskell package from the source (located in the specified Git repository)."]}),"\n",(0,s.jsx)(l.h2,{id:"development-shell",children:"Development shell"}),"\n",(0,s.jsxs)(l.p,{children:["A Haskell development environment can be provided in one of the two ways. The native way will use the (language-independent) ",(0,s.jsx)(l.code,{children:"mkShell"})," function (Generic shell). However to get full IDE support, it is best to use the (haskell-specific) ",(0,s.jsx)(l.code,{children:"shellFor"})," function (Haskell shell)."]}),"\n",(0,s.jsx)(l.h3,{id:"haskell-shell",children:"Haskell shell"}),"\n",(0,s.jsx)(l.admonition,{title:"To learn more",type:"info",children:(0,s.jsxs)(l.ul,{children:["\n",(0,s.jsx)(l.li,{children:(0,s.jsxs)(l.a,{href:"https://nixos.org/manual/nixpkgs/unstable/#haskell-shellFor",children:["Official manual on ",(0,s.jsx)(l.code,{children:"shellFor"})]})}),"\n"]})}),"\n",(0,s.jsxs)(l.p,{children:['Suppose we have a Haskell project called "foo" with ',(0,s.jsx)(l.code,{children:"foo.cabal"}),". You would create the development shell for this project as follows:"]}),"\n",(0,s.jsx)(l.pre,{children:(0,s.jsx)(l.code,{className:"language-nix",children:"devShells.default = pkgs.haskellPackages.shellFor {\n  packages = p: [\n    p.foo\n  ];\n  buildInputs = with pkgs.haskellPackages; [\n    ghcid\n    cabal-install\n    haskell-language-server\n  ];\n}\n"})}),"\n",(0,s.jsxs)(l.p,{children:["The ",(0,s.jsx)(l.code,{children:"packages"})," argument to ",(0,s.jsx)(l.code,{children:"shellFor"})," simply indicates that the given packages are available locally in the flake root, and that ",(0,s.jsx)(l.code,{children:"cabal"})," should build them from the local source (rather than using the Nix store derivation for example). The ",(0,s.jsx)(l.code,{children:"buildInputs"})," argument is similar to that of ",(0,s.jsx)(l.code,{children:"mkShell"})," -- it allows you to specify the packages you want to be made available in the development shell."]}),"\n",(0,s.jsxs)(l.p,{children:["From inside of ",(0,s.jsx)(l.code,{children:"nix develop"})," shell, launch your pre-configured text editor (for example, VSCode with the ",(0,s.jsx)(l.a,{href:"https://marketplace.visualstudio.com/items?itemName=haskell.haskell",children:"Haskell extension"})," installed). You should have full IDE support."]}),"\n",(0,s.jsx)(l.h2,{id:"example",children:"Example"}),"\n",(0,s.jsxs)(l.p,{children:["The flake for ",(0,s.jsx)(l.a,{href:"https://github.com/srid/haskell-multi-nix",children:"haskell-multi-nix"}),' is presented below. This project has two Haskell packages "foo" and "bar".']}),"\n",(0,s.jsx)(l.pre,{children:(0,s.jsx)(l.code,{className:"language-nix",children:'{\n  inputs = {\n    nixpkgs.url = "github:nixos/nixpkgs/nixpkgs-unstable";\n  };\n  outputs = { self, nixpkgs, ... }:\n    let\n      # TODO: Change this to your current system, or use flake-utils/flake-parts.\n      system = "aarch64-darwin";\n      pkgs = nixpkgs.legacyPackages.${system};\n      overlay = self: super: {\n        # Local packages in the repository\n        foo = self.callCabal2nix "foo" ./foo { };\n        bar = self.callCabal2nix "bar" ./bar { };\n        # TODO: Put any library dependency overrides here\n      };\n      # Extend the `pkgs.haskellPackages` attrset using an overlay.\n      #\n      # Note that we can also extend the package set using more than one\n      # overlay. To do that we can either chain the `extend` calls or use\n      # the `composeExtensions` (or `composeManyExtensions`) function to\n      # merge the overlays.\n      haskellPackages\' = pkgs.haskellPackages.extend overlay;\n    in\n    {\n      packages.${system} = {\n        inherit (haskellPackages\') foo bar;\n        default = haskellPackages\'.bar;\n      };\n      # This is how we provide a multi-package dev shell in Haskell.\n      # By using the `shellFor` function.\n      devShells.${system}.default = haskellPackages\'.shellFor {\n        packages = p: [\n          p.foo\n          p.bar\n        ];\n        buildInputs = with haskellPackages\'; [\n          ghcid\n          cabal-install\n          haskell-language-server\n        ];\n      };\n    };\n}\n'})}),"\n",(0,s.jsxs)(l.p,{children:["You can confirm that the package builds by running either ",(0,s.jsx)(l.code,{children:"nix build .#foo"})," or ",(0,s.jsx)(l.code,{children:"nix build .#bar"}),", as well as that IDE support is configured correctly by running ",(0,s.jsx)(l.code,{children:"nix develop -c haskell-language-server"}),"."]}),"\n",(0,s.jsxs)(l.p,{children:["A variation of this flake supporting multiple systems (via use of flake-parts) can be found ",(0,s.jsx)(l.a,{href:"https://github.com/srid/haskell-multi-nix/blob/nixpkgs/flake.nix",children:"here"}),"."]})]})}function d(e={}){const{wrapper:l}={...(0,a.a)(),...e.components};return l?(0,s.jsx)(l,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},1151:(e,l,n)=>{n.d(l,{Z:()=>t,a:()=>o});var s=n(7294);const a={},i=s.createContext(a);function o(e){const l=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(l):{...l,...e}}),[l,e])}function t(e){let l;return l=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(i.Provider,{value:l},e.children)}}}]);